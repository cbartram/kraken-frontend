<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>LocalPathfinder (lib 1.0.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.7.1.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LocalPathfinder (lib 1.0.0 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.kraken.api.service.pathfinding</a></div>
<h2 title="Class LocalPathfinder" class="title">Class LocalPathfinder</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.kraken.api.service.pathfinding.LocalPathfinder</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>@Singleton
public class <span class="typeNameLabel">LocalPathfinder</span>
extends java.lang.Object</pre>
<div class="block"><p>
 The <code>LocalPathfinder</code> class is responsible for pathfinding within a local 104x104 tile 3D game scene.
 It provides methods to compute paths using Breadth First Search (BFS),
 determine sparse paths for waypoints where directional changes occur, render paths visually, and validate
 the reachability of points within the currently loaded scene. This class is useful for
 AI, navigation, and player movement scenarios.
 </p>

 <p>
 The class supports the following functionalities:
 </p>
 <ul>
   <li>Compute the shortest path between points in a game scene, including computing sparse waypoints with <a href="#findSparsePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)"><code>findSparsePath(WorldPoint, WorldPoint)</code></a>.</li>
   <li>Render computed paths on a graphical interface using methods like <a href="#renderMinimapPath(java.util.List,java.awt.Graphics2D,java.awt.Color)"><code>renderMinimapPath(List, Graphics2D, Color)</code></a> and <a href="#renderPath(java.util.List,java.awt.Graphics2D,java.awt.Color)"><code>renderPath(List, Graphics2D, Color)</code></a>.</li>
   <li>Handle approximate pathfinding if exact target points are not reachable.</li>
 </ul></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">LocalPathfinder</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findApproximatePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldArea)">findApproximatePath</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                   net.runelite.api.coords.WorldArea&nbsp;area)</code></th>
<td class="colLast">
<div class="block">Finds an approximate path to a random reachable tile within a specified WorldArea.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findApproximatePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">findApproximatePath</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                   net.runelite.api.coords.WorldPoint&nbsp;target)</code></th>
<td class="colLast">
<div class="block">Finds an approximate path to a random reachable tile within a default radius of 5 tiles
 around the target location.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findApproximatePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint,int)">findApproximatePath</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                   net.runelite.api.coords.WorldPoint&nbsp;target,
                   int&nbsp;radius)</code></th>
<td class="colLast">
<div class="block">Finds an approximate path to a random reachable tile within a specified radius
 around the target location.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>net.runelite.api.coords.WorldPoint</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findEdgeOfScene(net.runelite.api.coords.WorldPoint)">findEdgeOfScene</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;target)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">findPath</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
        net.runelite.api.coords.WorldPoint&nbsp;target)</code></th>
<td class="colLast">
<div class="block">Calculates and returns a path from a starting point to a target point within the game world.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPathWithBackoff(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">findPathWithBackoff</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                   net.runelite.api.coords.WorldPoint&nbsp;target)</code></th>
<td class="colLast">
<div class="block">Attempts to find a path to the target.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findSparsePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">findSparsePath</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
              net.runelite.api.coords.WorldPoint&nbsp;target)</code></th>
<td class="colLast">
<div class="block">Finds a sparse path between a starting point and a target point by filtering
 out unnecessary intermediate points from a previously computed dense path.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.Tile&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findWaypointsTo(net.runelite.api.Tile,net.runelite.api.Tile)">findWaypointsTo</a></span>&#8203;(net.runelite.api.Tile&nbsp;from,
               net.runelite.api.Tile&nbsp;to)</code></th>
<td class="colLast">
<div class="block">Finds the waypoints needed to navigate from the starting <code>Tile</code> to the destination <code>Tile</code>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reachableTiles(net.runelite.api.coords.WorldPoint)">reachableTiles</a></span>&#8203;(net.runelite.api.coords.WorldPoint&nbsp;origin)</code></th>
<td class="colLast">
<div class="block">Returns a list of all reachable tiles from the origins position using a breadth-first search algorithm.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#renderMinimapPath(java.util.List,java.awt.Graphics2D,java.awt.Color)">renderMinimapPath</a></span>&#8203;(java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;path,
                 java.awt.Graphics2D&nbsp;graphics,
                 java.awt.Color&nbsp;color)</code></th>
<td class="colLast">
<div class="block">Renders a path on the minimap.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#renderPath(java.util.List,java.awt.Graphics2D,java.awt.Color)">renderPath</a></span>&#8203;(java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;path,
          java.awt.Graphics2D&nbsp;graphics,
          java.awt.Color&nbsp;pathColor)</code></th>
<td class="colLast">
<div class="block">Renders a series of tiles representing a path on the game canvas.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LocalPathfinder</h4>
<pre>public&nbsp;LocalPathfinder()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="findSparsePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findSparsePath</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;findSparsePath&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                                                                         net.runelite.api.coords.WorldPoint&nbsp;target)</pre>
<div class="block">Finds a sparse path between a starting point and a target point by filtering
 out unnecessary intermediate points from a previously computed dense path.

 <p>The method calculates directional changes in the dense path and retains
 only the waypoints where the direction changes, along with the final destination.
 This ensures a simplified path that accurately represents the required turns or
 path changes while omitting redundant points.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>start</code> - @WorldPoint representing the starting location of the path.</dd>
<dd><code>target</code> - @WorldPoint representing the destination point of the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A @List of @WorldPoint objects representing the sparse path.
         Returns an empty list if no path can be computed.</dd>
</dl>
</li>
</ul>
<a id="findPath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPath</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;findPath&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                                                                   net.runelite.api.coords.WorldPoint&nbsp;target)</pre>
<div class="block">Calculates and returns a path from a starting point to a target point within the game world.
 If the target point is outside the scene, the method attempts to determine the edge of the
 scene closest to the target and calculates a path to that edge instead.

 <p>If the target point is within the loaded scene, the method directly computes the path
 to the target using the <code>findScenePath</code> method. If the target is outside the scene,
 it finds the nearest edge point to the target and calculates a path to that point.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>start</code> - @WorldPoint representing the starting location of the path.</dd>
<dd><code>target</code> - @WorldPoint representing the destination point of the path.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A @List of @WorldPoint objects representing the calculated path
         from the start to the target (or closest reachable edge point). If no path can be calculated,
         an empty list is returned.</dd>
</dl>
</li>
</ul>
<a id="findPathWithBackoff(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPathWithBackoff</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;findPathWithBackoff&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                                                                              net.runelite.api.coords.WorldPoint&nbsp;target)</pre>
<div class="block">Attempts to find a path to the target. If the target is unreachable, it attempts to find
 a path to a tile closer to the start point by "backing off" from the target in an
 exponential/incremental fashion.

 <p>The backoff strategy works by calculating points along the line between the target
 and the start. It steps back by 1 tile, then 3, then 6, then 10, etc., until a
 reachable path is found or the search backs up all the way to the start.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>start</code> - The starting WorldPoint.</dd>
<dd><code>target</code> - The desired target WorldPoint.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A List of WorldPoints representing the path to the target or the best approximate
 location found. Returns an empty list if no path can be found.</dd>
</dl>
</li>
</ul>
<a id="findApproximatePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findApproximatePath</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;findApproximatePath&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                                                                              net.runelite.api.coords.WorldPoint&nbsp;target)</pre>
<div class="block">Finds an approximate path to a random reachable tile within a default radius of 5 tiles
 around the target location.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>start</code> - The starting WorldPoint.</dd>
<dd><code>target</code> - The target WorldPoint.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of WorldPoints representing the path to the approximate target.</dd>
</dl>
</li>
</ul>
<a id="findApproximatePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldPoint,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findApproximatePath</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;findApproximatePath&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                                                                              net.runelite.api.coords.WorldPoint&nbsp;target,
                                                                              int&nbsp;radius)</pre>
<div class="block">Finds an approximate path to a random reachable tile within a specified radius
 around the target location.

 <p>This method first calculates all reachable tiles from the start point using BFS.
 It then filters these tiles to find ones that lie within the specified square radius
 (Chebyshev distance) of the target point. Finally, it selects one of these candidates
 at random and computes a path to it.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>start</code> - The starting WorldPoint.</dd>
<dd><code>target</code> - The target WorldPoint.</dd>
<dd><code>radius</code> - The radius (in tiles) around the target to search for reachable tiles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of WorldPoints representing the path to the approximate target.</dd>
</dl>
</li>
</ul>
<a id="findApproximatePath(net.runelite.api.coords.WorldPoint,net.runelite.api.coords.WorldArea)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findApproximatePath</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;findApproximatePath&#8203;(net.runelite.api.coords.WorldPoint&nbsp;start,
                                                                              net.runelite.api.coords.WorldArea&nbsp;area)</pre>
<div class="block">Finds an approximate path to a random reachable tile within a specified WorldArea.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>start</code> - The starting WorldPoint.</dd>
<dd><code>area</code> - The WorldArea to search for reachable tiles within.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of WorldPoints representing the path to a random point within the area.</dd>
</dl>
</li>
</ul>
<a id="reachableTiles(net.runelite.api.coords.WorldPoint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reachableTiles</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;reachableTiles&#8203;(net.runelite.api.coords.WorldPoint&nbsp;origin)</pre>
<div class="block">Returns a list of all reachable tiles from the origins position using a breadth-first search algorithm.
 This method considers the collision data to determine which tiles can be reached.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>origin</code> - The point to query from</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of WorldPoint objects representing all reachable tiles from the origin.</dd>
</dl>
</li>
</ul>
<a id="findEdgeOfScene(net.runelite.api.coords.WorldPoint)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findEdgeOfScene</h4>
<pre class="methodSignature">public&nbsp;net.runelite.api.coords.WorldPoint&nbsp;findEdgeOfScene&#8203;(net.runelite.api.coords.WorldPoint&nbsp;target)</pre>
</li>
</ul>
<a id="findWaypointsTo(net.runelite.api.Tile,net.runelite.api.Tile)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findWaypointsTo</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;net.runelite.api.Tile&gt;&nbsp;findWaypointsTo&#8203;(net.runelite.api.Tile&nbsp;from,
                                                             net.runelite.api.Tile&nbsp;to)</pre>
<div class="block">Finds the waypoints needed to navigate from the starting <code>Tile</code> to the destination <code>Tile</code>.
 This method calculates a path using directional and distance matrices, while considering collision data
 within the game world. If a direct path is not possible, it searches for the closest accessible tile
 around the destination.

 <p>Note that both the starting and destination tiles must reside on the same plane (z-coordinate).
 If they are not, this method will return <code>null</code>.</p>

 Credit to Vitalite and TonicBox for this methods implementation. It was taken from their scene API:
 <a href="https://github.com/Tonic-Box/VitaLite/blob/main/api/src/main/java/com/tonic/api/game/SceneAPI.java">Link</a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>from</code> - the starting <code>Tile</code> from which the path needs to be calculated.</dd>
<dd><code>to</code> - the destination <code>Tile</code> to which the path needs to lead.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of <code>Tile</code> objects representing the calculated waypoints to the destination,
         or <code>null</code> if the path cannot be calculated (e.g., due to inaccessible areas or mismatched planes).</dd>
</dl>
</li>
</ul>
<a id="renderMinimapPath(java.util.List,java.awt.Graphics2D,java.awt.Color)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>renderMinimapPath</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;renderMinimapPath&#8203;(java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;path,
                              java.awt.Graphics2D&nbsp;graphics,
                              java.awt.Color&nbsp;color)</pre>
<div class="block">Renders a path on the minimap.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - The list of WorldPoints representing the path.</dd>
<dd><code>graphics</code> - The graphics context to draw on.</dd>
<dd><code>color</code> - The color to use for drawing the path.</dd>
</dl>
</li>
</ul>
<a id="renderPath(java.util.List,java.awt.Graphics2D,java.awt.Color)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>renderPath</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;renderPath&#8203;(java.util.List&lt;net.runelite.api.coords.WorldPoint&gt;&nbsp;path,
                       java.awt.Graphics2D&nbsp;graphics,
                       java.awt.Color&nbsp;pathColor)</pre>
<div class="block">Renders a series of tiles representing a path on the game canvas.
 This includes drawing connected lines between the tiles and optionally
 highlighting the last tile in the path.

 <p> The method uses the provided Graphics2D instance to draw
 on the screen and a Color to style the tiles.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - The list of WorldPoint objects representing the path.
                   Each point is rendered on the game canvas.</dd>
<dd><code>graphics</code> - The Graphics2D instance used to render the path on the screen.</dd>
<dd><code>pathColor</code> - The Color used to draw the tiles on the path. The last tile
                   is highlighted in red with partial transparency.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
